# Лабораторная работа №1
Карандашева Анастасия, 368273, группа P3332

Цель: освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

Индивидуальный вариант: задачи 5 и 26 [проекта Эйлер](https://projecteuler.net/archives).

## Описание задач и основных алгоритмов их решения

### Задача 5 

**Условие:**  
2520 – это наименьшее число, которое делится без остатка на все числа от 1 до 10.  
Какое наименьшее положительное число делится без остатка на все числа от 1 до 20?

**Общий алгоритм:**  
1. **Разложить на простые множители:** Для каждого числа от 1 до 20 разложить его на простые множители (например, 12 = 2² × 3¹).  
2. **Найти НОК:** Взять максимальные степени всех простых чисел, встречающихся в разложениях. Например, для простого числа 2 максимальная степень в диапазоне 1-20 — 2⁴ (так как 16 = 2⁴).  
3. **Вычислить произведение:** Умножить все эти простые числа в максимальных степенях. Формула:  
   НОК(1, 2, ..., 20) = ∏ p^max(k)  
   где p – простое число, а max(k) – его наибольшая степень, не превышающая 20.

**Ожидаемый ответ:**  
232792560


### Задача 26 

**Условие:**  
Дробь с единицей в числителе называется единичной дробью. Десятичные представления единичных дробей со знаменателями от 2 до 10:

```
1/2 = 0.5
1/3 = 0.(3)
1/4 = 0.25
1/5 = 0.2
1/6 = 0.1(6)
1/7 = 0.(142857)
1/8 = 0.125
1/9 = 0.(1)
1/10 = 0.1
```

Здесь 0.1(6) означает 0.166666... и имеет период длины 1. Видно, что 1/7 имеет период длины 6.  
Найдите значение d < 1000, для которого 1/d имеет самый длинный период в десятичной записи.

**Общий алгоритм:**  
1. **Игнорировать непериодические дроби:** Для знаменателей, содержащих только множители 2 и 5, дробь конечная (период отсутствует).  
2. **Вычислить длину периода:** 
   - Нужно найти минимальное k, такое что 10ᵏ при делении на d даёт остаток 1;
   - Это число k и будет длиной периода десятичной дроби;
   - Простой пример: для d = 7: 10¹ = 10 (остаток 3), 10² = 100 (остаток 2), ..., 10⁶ = 1000000 (остаток 1), значит, длина периода = 6.
3. **Найти максимум:** Перебрать d от 2 до 999, вычислить длину периода и выбрать d с наибольшей длиной.

**Ожидаемый ответ:**  
983

## Реализации решения задачи 5

### 1.1. Хвостовая рекурсия
```clojure
(defn gcd [a b] ; Алгоритм Евклида для НОД
  (if (zero? b)
    a
    (recur b (mod a b)))) 

(defn lcm [a b] ; НОК
  (if (or (zero? a) (zero? b))
    0
    (/ (* a b) (gcd a b))))

(defn smallest-multiple-tail [n]
  (let [nums (range 2 (inc n))]
    (loop [remaining nums
           result 1]
      (if (empty? remaining)
        result
        (recur (rest remaining)
               (lcm result (first remaining)))))))
```

### 1.2. Обычная рекурсия
```clojure
(defn gcd-rec [a b]
  (if (zero? b)
    a
    (gcd-rec b (mod a b))))

(defn lcm-rec [a b]
  (/ (* a b) (gcd-rec a b)))

(defn smallest-multiple-rec [n]
  (letfn [(helper [nums acc]
            (if (empty? nums)
              acc
              (helper (rest nums) 
                      (lcm-rec acc (first nums)))))]
    (helper (range 2 (inc n)) 1)))
```

### 2. Модульная версия
```clojure
(defn gcd [a b]
  (if (zero? b)
    a
    (recur b (mod a b)))) 

(defn lcm [a b] ; НОК
  (if (or (zero? a) (zero? b))
    0
    (/ (* a b) (gcd a b))))

(defn smallest-multiple-modular [n]
  (reduce lcm 1 (range 2 (inc n)))) ; Генерация последовательности и свертка с вычислением НОК
```

### 3. Версия с отображением (map) и редукцией
```clojure
(defn smallest-multiple-map [n]
  (let [numbers (range 2 (inc n))
        lcm-pairs (map (fn [x] [x x]) numbers)] ; Создаем пары [a b] для LCM
    (reduce (fn [acc [a b]] (lcm acc a)) 1 lcm-pairs)))
```


### 4. Версия со спец. синтаксисом для циклов (for, doseq)
```clojure
(defn smallest-multiple-for [n]
  (let [numbers (range 2 (inc n))]
    (loop [result 1
           [x & xs] numbers]
      (if (nil? x)
        result
        (recur (lcm result x) xs)))))
```

### 5. Версия с бесконечными списками
```clojure
(defn smallest-multiple-lazy-step [n]
  (let [numbers (range 2 (inc n))]
    (->> (reductions lcm 1 numbers)    ; Последовательность НОК: 1, lcm(1,2), lcm(lcm(1,2),3)...
         (last))))                     ; Берем последний элемент
```

### 6. Реализация на Java
```java
    public static long gcd(long a, long b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
    
    public static long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }

    // Основная функция для поиска искомого числа
    public static long smallestMultiple(int n) {
        long result = 1; 
        for (int i = 2; i <= n; i++) {
            result = lcm(result, i);
        }
        return result;
    }
```


## Реализации решения задачи 26

### 1.1. Хвостовая рекурсия
```clojure
(defn euler-26-tail-recursion [limit]
  (letfn [(find-max-cycle [n max-d max-len]
            (if (< n 2)
              max-d
              (let [len (cycle-length n)]
                (if (> len max-len)
                  (recur (dec n) n len)
                  (recur (dec n) max-d max-len)))))]
    (find-max-cycle (dec limit) 0 0)))
```

### 1.2. Обычная рекурсия 
```clojure
(defn euler-26-recursion [limit]
  (letfn [(helper [n max-d max-len]
            (if (< n 2)
              max-d
              (let [curr-len (cycle-length n)]
                (if (> curr-len max-len)
                  (recur (dec n) n curr-len)
                  (recur (dec n) max-d max-len)))))]
    (helper (dec limit) 0 0)))
```

### 2-3. Модульная реализация с map
```clojure
(defn euler-26-modular [limit]
  (->> (range 2 limit)
       (map (fn [d] {:d d :len (cycle-length d)}))
       (reduce (fn [max-item item]
                 (if (> (:len item) (:len max-item))
                   item
                   max-item))
               {:d 0 :len 0})
       :d))
```


### 4. Специальный синтаксис для циклов
```clojure
(defn euler-26-loop [limit]
  (loop [d (dec limit)
         max-d 0
         max-len 0]
    (if (< d 2)
      max-d
      (let [len (cycle-length d)]
        (if (> len max-len)
          (recur (dec d) d len)
          (recur (dec d) max-d max-len))))))
```

### 5. Работа с бесконечными списками
```clojure
(defn euler-26-lazy [limit]
  (let [numbers (range 2 limit)
        cycles (map (fn [d] [d (cycle-length d)]) numbers)]
    (->> cycles
         (apply max-key second)
         first)))
```

### 6. Реализация на Java
```java
 public static int cycleLength(int n) {
        if (n <= 1) {
            throw new IllegalArgumentException("n must be greater than 1");
        }
        
        int remainder = 1;
        java.util.Map<Integer, Integer> seen = new java.util.HashMap<>();
        int position = 0;
        
        while (remainder != 0) {
            if (seen.containsKey(remainder)) {
                return position - seen.get(remainder);
            }
            seen.put(remainder, position);
            remainder = (remainder * 10) % n;
            position++;
        }
        
        return 0; // Конечная десятичная дробь
    }
    
    public static int longestRecurringCycle(int limit) {
        int maxD = 0;
        int maxLen = 0;
        
        for (int d = 2; d < limit; d++) {
            int len = cycleLength(d);
            if (len > maxLen) {
                maxLen = len;
                maxD = d;
            }
        }
        
        return maxD;
    }
```

## Выводы




