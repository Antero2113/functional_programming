# Лабораторная работа 2: Реализация Bag (Multiset) на основе Separate Chaining Hashmap
Карандашева Анастасия, P3332

## Описание проекта

Данный проект представляет собой реализацию структуры данных **Bag (Multiset)** на основе **Separate Chaining Hashmap** на языке Clojure. Bag (мультимножество) — это структура данных, которая позволяет хранить элементы с учетом их кратности (количества вхождений).


## Реализованные модули

#### 1. Добавление и удаление элементов
- **`bag-conj`** — добавляет элемент в bag, увеличивая его счетчик
- **`bag-disj`** — удаляет один экземпляр элемента из bag, уменьшая его счетчик

#### 2. Фильтрация
- **`bag-filter`** — фильтрует элементы bag по предикату, сохраняя кратность элементов

#### 3. Отображение (map)
- **`bag-map`** — применяет функцию к каждому элементу bag с учетом кратности

#### 4. Свертки (левая и правая)
- **`reduce-left`** — левая свертка (foldl), обрабатывает элементы слева направо
- **`reduce-right`** — правая свертка (foldr), обрабатывает элементы справа налево

#### 5. Моноид
- **`bag-union`** — операция объединения двух bags, которая:
  - **Ассоциативна**: `(bag-union (bag-union a b) c) = (bag-union a (bag-union b c))`
  - **Имеет нейтральный элемент**: `(bag-union empty-bag b) = b` и `(bag-union b empty-bag) = b`
  - **Суммирует кратности**: при объединении счетчики элементов складываются

### Тестирование

#### Unit Testing
Реализованы unit-тесты для:
- Базовых операций (создание, добавление, удаление)
- Создания из коллекций
- Функций высшего порядка (filter, map, reduce)
- Моноидных свойств
- Сравнения bags

#### Property-Based Testing
Реализовано **4 property-based теста** (требуется минимум 3):

1. **`monoid-associativity`** — проверяет ассоциативность операции объединения
2. **`monoid-identity`** — проверяет свойства нейтрального элемента
3. **`count-consistency`** — проверяет согласованность подсчета элементов
4. **`add-remove-consistency`** — проверяет инвертируемость операций добавления/удаления

Каждый тест выполняется 50 раз с различными случайными входными данными.

## Описание функций

### Создание и базовые операции

#### `empty-bag`
```clojure
(empty-bag)
(empty-bag {:hash-fn custom-hash :eq-fn custom-eq :load-factor 0.75})
```
Создает пустой bag. Может принимать опции для настройки функции хеширования, функции сравнения и коэффициента загрузки.

#### `bag`
```clojure
(bag [1 2 3 2 1])
(bag coll {:hash-fn custom-hash})
```
Создает bag из коллекции элементов. Подсчитывает кратность каждого элемента.

#### `bag-conj`
```clojure
(bag-conj bag element)
```
Добавляет элемент в bag, увеличивая его счетчик на 1. Автоматически расширяет хеш-таблицу при необходимости.

#### `bag-disj`
```clojure
(bag-disj bag element)
```
Удаляет один экземпляр элемента из bag. Если элемент отсутствует, возвращает bag без изменений.

### Запросы

#### `get-count`
```clojure
(get-count bag element)
```
Возвращает количество вхождений элемента в bag.

#### `bag-contains?`
```clojure
(bag-contains? bag element)
```
Проверяет наличие элемента в bag (возвращает `true`, если счетчик > 0).

#### `count-elements`
```clojure
(count-elements bag)
```
Возвращает общее количество элементов с учетом кратности.

#### `distinct-count`
```clojure
(distinct-count bag)
```
Возвращает количество уникальных элементов в bag.

### Функции высшего порядка

#### `bag-filter`
```clojure
(bag-filter even? bag)
```
Фильтрует элементы bag по предикату, сохраняя кратность прошедших проверку элементов.

#### `bag-map`
```clojure
(bag-map inc bag)
```
Применяет функцию к каждому элементу bag с учетом кратности. Каждый экземпляр элемента обрабатывается отдельно.

#### `reduce-left`
```clojure
(reduce-left + 0 bag)
(reduce-left (fn [acc x] (conj acc x)) [] bag)
```
Левая свертка (foldl). Обрабатывает элементы слева направо. Учитывает кратность элементов.

#### `reduce-right`
```clojure
(reduce-right + 0 bag)
(reduce-right (fn [acc x] (conj acc x)) [] bag)
```
Правая свертка (foldr). Обрабатывает элементы справа налево. Учитывает кратность элементов.

### Моноидные операции

#### `bag-union`
```clojure
(bag-union bag1 bag2)
```
Объединяет два bags, суммируя счетчики элементов. Является моноидной операцией:
- **Ассоциативна**: порядок группировки не важен
- **Имеет нейтральный элемент**: `empty-bag`
- **Идемпотентна**: `(bag-union bag bag) = bag` (с удвоенными счетчиками)

### Сравнение

#### `bag-equals?`
```clojure
(bag-equals? bag1 bag2)
```
Эффективно сравнивает два bags. Возвращает `true`, если:
- Общее количество элементов одинаково
- Количество уникальных элементов одинаково
- Счетчики для каждого элемента совпадают

### Утилиты

#### `bag-seq`
```clojure
(bag-seq bag)
```
Возвращает последовательность всех элементов с учетом кратности.

#### `bag-distinct-seq`
```clojure
(bag-distinct-seq bag)
```
Возвращает множество уникальных элементов.

#### `bag-frequencies`
```clojure
(bag-frequencies bag)
```
Возвращает map с частотами элементов (элемент → количество вхождений).

#### `bag->vector`
```clojure
(bag->vector bag)
```
Преобразует bag в вектор всех элементов.

#### `bag->string`
```clojure
(bag->string bag)
```
Возвращает строковое представление bag.

## Ключевые моменты Clojure реализации

### 1. Использование `defrecord`

```clojure
(defrecord Node [key count next])
(defrecord SCBag [buckets size hash-fn eq-fn load-factor])
```

**`defrecord`** создает неизменяемые типы данных:
- Поля доступны через ключевые слова (`:key`, `:count`, `:next`)
- Поддерживает протоколы и интерфейсы
- Эффективен по памяти и производительности
- Автоматически реализует `equals` и `hashCode` на основе значений полей

### 2. Threading макросы (`->` и `->>`)

```clojure
(-> sc-bag
    (assoc :buckets (assoc buckets bucket-idx new-bucket))
    (update :size + (bucket-size-change current-bucket new-bucket element eq-fn))
    ensure-capacity)
```

**Threading макрос `->`** передает результат предыдущего выражения как первый аргумент следующему:
- Улучшает читаемость кода
- Позволяет писать код в "естественном" порядке
- Избегает глубокой вложенности

### 3. Рекурсия с `loop` и `recur`

```clojure
(loop [acc init
       i 0]
  (if (>= i (count (:buckets sc-bag)))
    acc
    (recur new-acc (inc i))))
```

**`loop`/`recur`** обеспечивает хвостовую рекурсию:
- `recur` должен быть в хвостовой позиции
- Компилятор оптимизирует в цикл (TCO - Tail Call Optimization)
- Безопасна для глубокой рекурсии
- Используется вместо мутабельных переменных

### 4. Локальные функции с `letfn`

```clojure
(letfn [(build-list [current found?]
          (cond
            (nil? current) ...
            (eq-fn (:key current) key) ...
            :else ...))]
  (build-list bucket false))
```

**`letfn`** позволяет определять локальные рекурсивные функции:
- Функции могут ссылаться друг на друга
- Полезно для рекурсивных алгоритмов
- Изолирует вспомогательные функции

### 5. Множественная диспетчеризация с `cond`

```clojure
(cond
  (nil? current) 0
  (eq-fn (:key current) element) (:count current)
  :else (recur (:next current)))
```

**`cond`** — это множественный `if`:
- Проверяет условия по порядку
- Возвращает значение первого истинного условия
- `:else` — всегда истинное условие для default case

### 6. Деструктуризация в параметрах функций

```clojure
([{:keys [hash-fn eq-fn load-factor]
   :or {hash-fn default-hash
        eq-fn default-eq
        load-factor 0.75}])
```

**Деструктуризация** извлекает значения из map:
- `:keys` извлекает значения по ключевым словам
- `:or` задает значения по умолчанию
- Упрощает работу с опциональными параметрами

### 7. Полиморфизм через `instance?`

```clojure
(if (instance? SCBag sc-bag)
  ;; Специализированная реализация для SCBag
  (reduce-left ...)
  ;; Fallback для обычных коллекций
  (filter pred sc-bag))
```

**`instance?`** проверяет тип во время выполнения:
- Позволяет писать полиморфный код
- Обеспечивает обратную совместимость с обычными коллекциями
- Позволяет постепенно мигрировать код

### 8. Функции высшего порядка

```clojure
(reduce (fn [acc x] 
          (let [hash-fn (:hash-fn acc)
                eq-fn (:eq-fn acc)
                ...]
            (-> acc
                (assoc :buckets ...)
                (update :size ...))))
        (empty-bag opts)
        coll)
```

**Функции как значения первого класса**:
- Функции могут быть аргументами других функций
- Анонимные функции через `fn`
- Замыкания захватывают окружающий контекст

### 9. Неизменяемые структуры данных

Все операции создают новые структуры:
- `assoc` создает новую map с измененными значениями
- `update` применяет функцию к значению и создает новую map
- Рекурсивное построение списков через `Node.` конструктор
- Нет мутации существующих структур

### 10. Property-Based Testing с test.check

```clojure
(defspec monoid-associativity 50
  (prop/for-all [v1 small-vector-gen
                 v2 small-vector-gen
                 v3 small-vector-gen]
    (let [b1 (bag v1)
          b2 (bag v2)
          b3 (bag v3)]
      (bag-equals? (bag-union (bag-union b1 b2) b3)
                   (bag-union b1 (bag-union b2 b3))))))
```

**Property-based testing** проверяет свойства для множества входных данных:
- Генераторы создают случайные входные данные
- Тесты проверяют инварианты, а не конкретные случаи
- Автоматически находит минимальный контрпример при ошибке

### 11. Расширение протоколов через `defmethod`

```clojure
(defmethod print-method SCBag [bag writer]
  (.write writer (bag->string bag)))
```

**Множественная диспетчеризация** через протоколы:
- `print-method` — протокол для кастомного вывода
- Позволяет определять поведение для разных типов
- Интеграция с системой вывода Clojure

### 12. Композиция функций

```clojure
(-> (hash-fn key)
    (mod num-buckets))
```

**Threading макрос `->`** для композиции:
- Передает результат как первый аргумент следующей функции
- Альтернатива вложенным вызовам
- Улучшает читаемость

### 13. Ленивые последовательности

```clojure
(for [bucket (:buckets sc-bag)
      :when bucket]
  (loop [current bucket
         total 0]
    ...))
```

**`for` comprehension** создает ленивые последовательности:
- `:when` фильтрует элементы
- Ленивое вычисление до момента использования
- Эффективно по памяти

### 14. Функции-утилиты

```clojure
(update acc elem (fnil inc 0))
```

**`fnil`** оборачивает функцию для обработки `nil`:
- Если первый аргумент `nil`, используется значение по умолчанию
- Удобно для работы с map, где ключ может отсутствовать

## Архитектура реализации

### Внутреннее представление

1. **`Node`** — узел связанного списка в bucket:
   - `key` — ключ элемента
   - `count` — количество вхождений
   - `next` — ссылка на следующий узел

2. **`SCBag`** — основная структура:
   - `buckets` — вектор buckets (связанных списков)
   - `size` — количество уникальных элементов
   - `hash-fn` — функция хеширования
   - `eq-fn` — функция сравнения
   - `load-factor` — коэффициент загрузки для рехеширования

### Алгоритм работы

1. **Хеширование**: элемент хешируется и помещается в соответствующий bucket
2. **Separate Chaining**: коллизии разрешаются через связанные списки
3. **Рехеширование**: при превышении load-factor таблица удваивается
4. **Неизменяемость**: все операции создают новые структуры

### Временная сложность

- **Добавление/удаление**: O(1) среднее, O(n) худший случай
- **Поиск**: O(1) среднее, O(n) худший случай
- **Фильтрация/Map**: O(n)
- **Объединение**: O(n + m), где n и m — размеры bags
- **Сравнение**: O(min(n, m)), где n и m — количество уникальных элементов

## Примеры использования

```clojure
;; Создание bag
(def b1 (bag [1 2 3 2 1]))
;; => #Bag{1 2, 2 2, 3 1}

;; Добавление элементов
(def b2 (-> (empty-bag)
            (bag-conj :a)
            (bag-conj :b)
            (bag-conj :a)))
;; => #Bag{:a 2, :b 1}

;; Подсчет элементов
(get-count b1 2)
;; => 2

(count-elements b1)
;; => 5

(distinct-count b1)
;; => 3

;; Фильтрация
(bag-filter even? (bag [1 2 3 4 5 2]))
;; => #Bag{2 2, 4 1}

;; Map
(bag-map inc (bag [1 2 3]))
;; => #Bag{2 1, 3 1, 4 1}

;; Свертки
(reduce-left + 0 (bag [1 2 3 2]))
;; => 8

;; Объединение
(bag-union (bag [1 2]) (bag [2 3]))
;; => #Bag{1 1, 2 2, 3 1}

;; Сравнение
(bag-equals? (bag [1 2 2]) (bag [2 1 2]))
;; => true
```

## Запуск тестов

```bash
lein test
```

## Заключение


