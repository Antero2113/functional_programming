# Лабораторная работа 2: Реализация Bag (Multiset) на основе Separate Chaining Hashmap
Карандашева Анастасия, P3332

## Описание проекта

Данный проект представляет собой реализацию структуры данных **Bag (Multiset)** на основе **Separate Chaining Hashmap** на языке Clojure. Bag (мультимножество) — это структура данных, которая позволяет хранить элементы с учетом их кратности (количества вхождений).


### Основные реализуемые операции

#### 1. Добавление и удаление элементов
- **`bag-conj`** — добавляет элемент в bag, увеличивая его счетчик
- **`bag-disj`** — удаляет один экземпляр элемента из bag, уменьшая его счетчик

#### 2. Фильтрация
- **`bag-filter`** — фильтрует элементы bag по предикату, сохраняя кратность элементов

#### 3. Отображение (map)
- **`bag-map`** — применяет функцию к каждому элементу bag с учетом кратности

#### 4. Свертки (левая и правая)
- **`reduce-left`** — левая свертка (foldl), обрабатывает элементы слева направо
- **`reduce-right`** — правая свертка (foldr), обрабатывает элементы справа налево

#### 5. Моноид
- **`bag-union`** — операция объединения двух bags, которая:
  - **Ассоциативна**: `(bag-union (bag-union a b) c) = (bag-union a (bag-union b c))`
  - **Имеет нейтральный элемент**: `(bag-union empty-bag b) = b` и `(bag-union b empty-bag) = b`
  - **Суммирует кратности**: при объединении счетчики элементов складываются

### Тестирование

#### Unit Testing
Реализованы unit-тесты для:
- Базовых операций (создание, добавление, удаление)
- Создания из коллекций
- Функций высшего порядка (filter, map, reduce)
- Моноидных свойств
- Сравнения bags

#### Property-Based Testing
Реализовано **4 property-based теста**:

1. **`monoid-associativity`** — проверяет ассоциативность операции объединения
2. **`monoid-identity`** — проверяет свойства нейтрального элемента
3. **`count-consistency`** — проверяет согласованность подсчета элементов
4. **`add-remove-consistency`** — проверяет инвертируемость операций добавления/удаления

Каждый тест выполняется 50 раз с различными случайными входными данными.

## Описание функций

### Создание и базовые операции

#### `empty-bag`
```clojure
(empty-bag)
(empty-bag {:hash-fn custom-hash :eq-fn custom-eq :load-factor 0.75})
```
Создает пустой bag. Может принимать опции для настройки функции хеширования, функции сравнения и коэффициента загрузки.

#### `bag`
```clojure
(bag [1 2 3 2 1])
(bag coll {:hash-fn custom-hash})
```
Создает bag из коллекции элементов. Подсчитывает кратность каждого элемента.

#### `bag-conj`
```clojure
(bag-conj bag element)
```
Добавляет элемент в bag, увеличивая его счетчик на 1. Автоматически расширяет хеш-таблицу при необходимости.

#### `bag-disj`
```clojure
(bag-disj bag element)
```
Удаляет один экземпляр элемента из bag. Если элемент отсутствует, возвращает bag без изменений.

### Запросы

#### `get-count`
```clojure
(get-count bag element)
```
Возвращает количество вхождений элемента в bag.

#### `bag-contains?`
```clojure
(bag-contains? bag element)
```
Проверяет наличие элемента в bag (возвращает `true`, если счетчик > 0).

#### `count-elements`
```clojure
(count-elements bag)
```
Возвращает общее количество элементов с учетом кратности.

#### `distinct-count`
```clojure
(distinct-count bag)
```
Возвращает количество уникальных элементов в bag.

### Функции высшего порядка

#### `bag-filter`
```clojure
(bag-filter even? bag)
```
Фильтрует элементы bag по предикату, сохраняя кратность прошедших проверку элементов.

#### `bag-map`
```clojure
(bag-map inc bag)
```
Применяет функцию к каждому элементу bag с учетом кратности. Каждый экземпляр элемента обрабатывается отдельно.

#### `reduce-left`
```clojure
(reduce-left + 0 bag)
(reduce-left (fn [acc x] (conj acc x)) [] bag)
```
Левая свертка (foldl). Обрабатывает элементы слева направо. Учитывает кратность элементов.

#### `reduce-right`
```clojure
(reduce-right + 0 bag)
(reduce-right (fn [acc x] (conj acc x)) [] bag)
```
Правая свертка (foldr). Обрабатывает элементы справа налево. Учитывает кратность элементов.

### Моноидные операции

#### `bag-union`
```clojure
(bag-union bag1 bag2)
```
Объединяет два bags, суммируя счетчики элементов. Является моноидной операцией:
- **Ассоциативна**: порядок группировки не важен
- **Имеет нейтральный элемент**: `empty-bag`
- **Идемпотентна**: `(bag-union bag bag) = bag` (с удвоенными счетчиками)

### Сравнение

#### `bag-equals?`
```clojure
(bag-equals? bag1 bag2)
```
Эффективно сравнивает два bags. Возвращает `true`, если:
- Общее количество элементов одинаково
- Количество уникальных элементов одинаково
- Счетчики для каждого элемента совпадают

### Утилиты

#### `bag-seq`
```clojure
(bag-seq bag)
```
Возвращает последовательность всех элементов с учетом кратности.

#### `bag-distinct-seq`
```clojure
(bag-distinct-seq bag)
```
Возвращает множество уникальных элементов.

#### `bag-frequencies`
```clojure
(bag-frequencies bag)
```
Возвращает map с частотами элементов (элемент → количество вхождений).

#### `bag->vector`
```clojure
(bag->vector bag)
```
Преобразует bag в вектор всех элементов.

#### `bag->string`
```clojure
(bag->string bag)
```
Возвращает строковое представление bag.

## Архитектура реализации

### Внутреннее представление

1. **`Node`** — узел связанного списка в bucket:
   - `key` — ключ элемента
   - `count` — количество вхождений
   - `next` — ссылка на следующий узел

2. **`SCBag`** — основная структура:
   - `buckets` — вектор buckets (связанных списков)
   - `size` — количество уникальных элементов
   - `hash-fn` — функция хеширования
   - `eq-fn` — функция сравнения
   - `load-factor` — коэффициент загрузки для рехеширования

### Алгоритм работы

1. **Хеширование**: элемент хешируется и помещается в соответствующий bucket
2. **Separate Chaining**: коллизии разрешаются через связанные списки
3. **Рехеширование**: при превышении load-factor таблица удваивается
4. **Неизменяемость**: все операции создают новые структуры
   

## Примеры использования

```clojure
;; Создание bag
(def b1 (bag [1 2 3 2 1]))
;; => #Bag{1 2, 2 2, 3 1}

;; Добавление элементов
(def b2 (-> (empty-bag)
            (bag-conj :a)
            (bag-conj :b)
            (bag-conj :a)))
;; => #Bag{:a 2, :b 1}

;; Подсчет элементов
(get-count b1 2)
;; => 2

(count-elements b1)
;; => 5

(distinct-count b1)
;; => 3

;; Фильтрация
(bag-filter even? (bag [1 2 3 4 5 2]))
;; => #Bag{2 2, 4 1}

;; Map
(bag-map inc (bag [1 2 3]))
;; => #Bag{2 1, 3 1, 4 1}

;; Свертки
(reduce-left + 0 (bag [1 2 3 2]))
;; => 8

;; Объединение
(bag-union (bag [1 2]) (bag [2 3]))
;; => #Bag{1 1, 2 2, 3 1}

;; Сравнение
(bag-equals? (bag [1 2 2]) (bag [2 1 2]))
;; => true
```

## Запуск тестов

```bash
lein test
```

## Заключение

В ходе лабораторной работы была реализована структура данных Bag (Multiset) на основе Separate Chaining Hashmap. Имела место попытка организовать полиморфизм и, как мне кажется, конструкции clojure defrecord, defmethod очень удобны для его реализации, так как позволяют автоматически организовать структуры. Ещё есть instance? - простая операция для определения того, кто перед нами и, соответственно, организации ветвления на реализации для разных типов данных (здесь это SC-bag и стандартные коллекции для сравнения). 

Также были реализованы все требуемые функции, в том числе моноид, для которого необходимо было описать тесты, основываясь на свойствах (предварительно в них разобравшись). Кроме того, мне по-прежнему очень нравится то, как выглядят свертки и рекурсивные вызовы в clojure, в том числе с их записью через макросы (достаточно читаемо и красиво).

В целом, мы получили библиотеку методов для sc-bag, во внутреннем представлении бакетов которой организуем цепочки узлов, храним уникальные элементы и количества их вхождений. В методах же основного API мы реализуем как алгоритмы с использованием описанного внутреннего представления структуры данных, так и алгоритмы для стандартных коллекций (менее оптимизированные, но рабочие).
