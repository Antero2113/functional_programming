# Лабораторная работа 2: Реализация Bag (Multiset) на основе Separate Chaining Hashmap
Карандашева Анастасия, P3332

## Описание проекта

Данный проект представляет собой реализацию структуры данных **Bag (Multiset)** на основе **Separate Chaining Hashmap** на языке Clojure. Bag (мультимножество) — это структура данных, которая позволяет хранить элементы с учетом их кратности (количества вхождений).


### Основные реализуемые операции

#### 1. Добавление и удаление элементов
- **`bag-conj`** — добавляет элемент в bag, увеличивая его счетчик
- **`bag-disj`** — удаляет один экземпляр элемента из bag, уменьшая его счетчик

#### 2. Фильтрация
- **`bag-filter`** — фильтрует элементы bag по предикату, сохраняя кратность элементов

#### 3. Отображение (map)
- **`bag-map`** — применяет функцию к каждому элементу bag с учетом кратности

#### 4. Свертки (левая и правая)
- **`reduce-left`** — левая свертка (foldl), обрабатывает элементы слева направо
- **`reduce-right`** — правая свертка (foldr), обрабатывает элементы справа налево

#### 5. Моноид
- **`bag-union`** — операция объединения двух bags, которая:
  - **Ассоциативна**: `(bag-union (bag-union a b) c) = (bag-union a (bag-union b c))`
  - **Имеет нейтральный элемент**: `(bag-union empty-bag b) = b` и `(bag-union b empty-bag) = b`
  - **Суммирует кратности**: при объединении счетчики элементов складываются

### Тестирование

#### Unit Testing
Реализованы **8 unit-тестов** для:
- Базовых операций (создание, добавление, удаление)
- Создания из коллекций
- Функций высшего порядка (filter, map, reduce)
- Проверки типов возвращаемых значений
- Моноидных свойств
- Сравнения bags
- Интерфейсов стандартных коллекций Clojure (Seqable, IPersistentCollection, ILookup, Associative, IFn)
- Работы со стандартными функциями Clojure
- Граничных случаев

#### Property-Based Testing
Реализовано **15 property-based тестов**:

1. **`bag-seq-returns-seqable`** — проверяет, что `bag-seq` возвращает seqable коллекцию
2. **`bag-distinct-seq-returns-seqable`** — проверяет, что `bag-distinct-seq` возвращает seqable коллекцию
3. **`monoid-associativity`** — проверяет ассоциативность операции объединения
4. **`monoid-identity`** — проверяет свойства нейтрального элемента
5. **`count-consistency`** — проверяет согласованность подсчета элементов
6. **`add-remove-consistency`** — проверяет инвертируемость операций добавления/удаления
7. **`filter-consistency`** — проверяет согласованность фильтрации
8. **`map-consistency`** — проверяет согласованность отображения
9. **`bag-interface-consistency`** — проверяет согласованность интерфейсов коллекций
10. **`bag-reduce-consistency`** — проверяет согласованность левой и правой сверток
11. **`bag-disj-consistency`** — проверяет корректность удаления элементов
12. **`bag-unique-properties`** — проверяет свойства уникальных элементов
13. **`bag-empty-properties`** — проверяет свойства пустого bag
14. **`bag-disj-first-element`** — проверяет удаление первого элемента
15. **`bag-union-frequencies`** — проверяет частоты элементов при объединении

Каждый тест выполняется 50 раз с различными случайными входными данными. Для генерации тестовых данных используется генератор `bag-gen`, который создает bag-и **напрямую** через `reduce bag-conj` из случайно сгенерированных элементов, без промежуточного создания векторов.

## Описание функций

### Создание и базовые операции

#### `empty-bag`
```clojure
(empty-bag)
(empty-bag {:hash-fn custom-hash :eq-fn custom-eq :load-factor 0.75})
```
Создает пустой bag. Может принимать опции для настройки функции хеширования, функции сравнения и коэффициента загрузки.

#### `bag`
```clojure
(bag [1 2 3 2 1])
(bag coll {:hash-fn custom-hash})
```
Создает bag из коллекции элементов. Подсчитывает кратность каждого элемента.

#### `bag-conj`
```clojure
(bag-conj bag element)
```
Добавляет элемент в bag, увеличивая его счетчик на 1. Автоматически расширяет хеш-таблицу при необходимости.

#### `bag-disj`
```clojure
(bag-disj bag element)
```
Удаляет один экземпляр элемента из bag. Если элемент отсутствует, возвращает bag без изменений.

### Запросы

#### `get-count`
```clojure
(get-count bag element)
```
Возвращает количество вхождений элемента в bag.

#### `bag-contains?`
```clojure
(bag-contains? bag element)
```
Проверяет наличие элемента в bag (возвращает `true`, если счетчик > 0).

#### `count-elements`
```clojure
(count-elements bag)
```
Возвращает общее количество элементов с учетом кратности.

#### `distinct-count`
```clojure
(distinct-count bag)
```
Возвращает количество уникальных элементов в bag.

### Функции высшего порядка

#### `bag-filter`
```clojure
(bag-filter even? bag)
```
Фильтрует элементы bag по предикату, сохраняя кратность прошедших проверку элементов.

#### `bag-map`
```clojure
(bag-map inc bag)
```
Применяет функцию к каждому элементу bag с учетом кратности. Каждый экземпляр элемента обрабатывается отдельно.

#### `reduce-left`
```clojure
(reduce-left + 0 bag)
(reduce-left (fn [acc x] (conj acc x)) [] bag)
```
Левая свертка (foldl). Обрабатывает элементы слева направо. Учитывает кратность элементов.

#### `reduce-right`
```clojure
(reduce-right + 0 bag)
(reduce-right (fn [acc x] (conj acc x)) [] bag)
```
Правая свертка (foldr). Обрабатывает элементы справа налево. Учитывает кратность элементов.

### Моноидные операции

#### `bag-union`
```clojure
(bag-union bag1 bag2)
```
Объединяет два bags, суммируя счетчики элементов. Является моноидной операцией:
- **Ассоциативна**: порядок группировки не важен
- **Имеет нейтральный элемент**: `empty-bag`
- **Идемпотентна**: `(bag-union bag bag) = bag` (с удвоенными счетчиками)

### Сравнение

#### `bag-equals?`
```clojure
(bag-equals? bag1 bag2)
```
Эффективно сравнивает два bags. Возвращает `true`, если:
- Общее количество элементов одинаково
- Количество уникальных элементов одинаково
- Счетчики для каждого элемента совпадают

### Утилиты

#### `bag-seq`
```clojure
(bag-seq bag)
```
Возвращает последовательность всех элементов с учетом кратности.

#### `bag-distinct-seq`
```clojure
(bag-distinct-seq bag)
```
Возвращает множество уникальных элементов.

#### `bag-frequencies`
```clojure
(bag-frequencies bag)
```
Возвращает map с частотами элементов (элемент → количество вхождений).

#### `bag->vector`
```clojure
(bag->vector bag)
```
Преобразует bag в вектор всех элементов.

#### `bag->string`
```clojure
(bag->string bag)
```
Возвращает строковое представление bag.

## Архитектура реализации

### Структура кода

Код организован в файле `core.clj` с четким разделением на секции:

1. **Внутреннее представление**:
   - **`Node`** — узел связанного списка в bucket:
     - `key` — ключ элемента
     - `count` — количество вхождений
     - `next` — ссылка на следующий узел
   - **`SCBag`** — основная структура, реализованная через `deftype`:
     - `buckets` — вектор buckets (связанных списков)
     - `size` — количество уникальных элементов
     - `hash-fn` — функция хеширования
     - `eq-fn` — функция сравнения
     - `load-factor` — коэффициент загрузки для рехеширования
     
     Использование `deftype` вместо `defrecord` позволяет явно реализовать все интерфейсы стандартных коллекций Clojure без конфликтов с автоматическими реализациями.

2. **Вспомогательные функции** — внутренние функции для работы с хеш-таблицей (хеширование, обновление buckets, рехеширование)

3. **Функции высшего порядка** — `reduce-left` и `reduce-right` для обхода элементов

4. **API SCBag** — специфичные функции для работы с bag:
   - Создание: `empty-bag`, `bag`
   - Модификация: `bag-conj`, `bag-disj`
   - Функции высшего порядка: `bag-filter`, `bag-map`

5. **Интеграция со стандартными коллекциями Clojure** — функции, работающие как с SCBag, так и с обычными коллекциями:
   - Запросы: `get-count`, `bag-contains?`, `count-elements`, `distinct-count`
   - Последовательности: `bag-seq`, `bag-distinct-seq`
   - Утилиты: `bag-frequencies`
   - Моноидные операции: `bag-union`, `bag-equals?`

6. **Утилиты** — преобразования и вывод (`bag->vector`, `bag->string`, `print-method`)

7. **Реализация интерфейсов стандартных коллекций Clojure** — явная реализация через `deftype` всех необходимых интерфейсов для полной интеграции со стандартными функциями Clojure

### Алгоритм работы

1. **Хеширование**: элемент хешируется и помещается в соответствующий bucket
2. **Separate Chaining**: коллизии разрешаются через связанные списки
3. **Рехеширование**: при превышении load-factor таблица удваивается
4. **Неизменяемость**: все операции создают новые структуры

## Реализация интерфейсов стандартных коллекций Clojure

Для полной интеграции `SCBag` со стандартными функциями Clojure реализованы следующие интерфейсы через `deftype`:

### 1. `clojure.lang.Seqable`
**Назначение**: Позволяет использовать `seq` для получения последовательности элементов bag.

**Реализованные методы**:
- `(seq [this])` — возвращает последовательность всех элементов с учетом кратности, или `nil` для пустого bag

**Использование**:
```clojure
(seq (bag [1 2 3 2]))  ; => (1 2 3 2) или другая перестановка
```

### 2. `clojure.lang.Counted`
**Назначение**: Позволяет использовать `count` для подсчета общего количества элементов.

**Реализованные методы**:
- `(count [this])` — возвращает общее количество элементов с учетом кратности

**Использование**:
```clojure
(count (bag [1 2 3 2]))  ; => 4
```

### 3. `clojure.lang.IPersistentCollection`
**Назначение**: Позволяет использовать стандартные операции с коллекциями: `cons`, `empty`, `equiv`.

**Реализованные методы**:
- `(cons [this o])` — добавляет элемент в bag (эквивалентно `bag-conj`)
- `(empty [this])` — возвращает пустой bag с теми же параметрами хеширования
- `(equiv [this o])` — проверяет равенство двух bags (эквивалентно `bag-equals?`)

**Использование**:
```clojure
(cons (bag [1 2]) 3)  ; => #Bag{1 1, 2 1, 3 1}
(empty (bag [1 2]))   ; => #Bag{}
(= (bag [1 2 2]) (bag [2 1 2]))  ; => true
```

### 4. `clojure.lang.ILookup`
**Назначение**: Позволяет использовать `get` для получения количества вхождений элемента.

**Реализованные методы**:
- `(valAt [this key])` — возвращает количество вхождений элемента или значение поля записи (для keywords)
- `(valAt [this key not-found])` — возвращает количество вхождений элемента или `not-found`, если элемент отсутствует

**Использование**:
```clojure
(get (bag [1 2 2 3]) 2)  ; => 2
(get (bag [1 2 2 3]) 5 :not-found)  ; => :not-found
(get (bag [1 2]) :buckets)  ; => доступ к внутреннему полю
```

### 5. `clojure.lang.IFn`
**Назначение**: Позволяет вызывать bag как функцию для получения количества вхождений элемента.

**Реализованные методы**:
- `(invoke [this key])` — возвращает количество вхождений элемента
- `(invoke [this key not-found])` — возвращает количество вхождений элемента или `not-found`

**Использование**:
```clojure
((bag [1 2 2 3]) 2)  ; => 2
((bag [1 2 2 3]) 5 :not-found)  ; => :not-found
```

### 6. `clojure.lang.Associative`
**Назначение**: Позволяет использовать `contains?` и `find` для проверки наличия элементов и получения записей.

**Реализованные методы**:
- `(containsKey [this key])` — проверяет наличие элемента в bag (эквивалентно `bag-contains?`)
- `(entryAt [this key])` — возвращает `MapEntry` с элементом и его количеством, или `nil`

**Использование**:
```clojure
(contains? (bag [1 2 3]) 2)  ; => true
(contains? (bag [1 2 3]) 4)  ; => false
(find (bag [1 2 2 3]) 2)     ; => [2 2] (MapEntry)
```

### Особенности реализации

1. **Двойная семантика для keywords**: При использовании keywords (например, `:buckets`, `:size`) методы интерфейсов работают с внутренними полями структуры, а не с элементами bag. Это позволяет сохранить доступ к метаданным структуры.

2. **Явная реализация через `deftype`**: Использование `deftype` вместо `defrecord` необходимо для полного контроля над реализацией интерфейсов, так как `defrecord` автоматически реализует многие интерфейсы для работы с полями записи, что конфликтует с желаемым поведением для элементов bag.

3. **Совместимость со стандартными функциями**: Благодаря реализации всех перечисленных интерфейсов, `SCBag` может использоваться со стандартными функциями Clojure:
   - `seq`, `count`, `cons`, `empty`, `=`
   - `get`, `contains?`, `find`
   - `some`, `every?`, `set`, `sort`
   - И многие другие функции, работающие с коллекциями

## Примеры использования

```clojure
;; Создание bag
(def b1 (bag [1 2 3 2 1]))
;; => #Bag{1 2, 2 2, 3 1}

;; Добавление элементов
(def b2 (-> (empty-bag)
            (bag-conj :a)
            (bag-conj :b)
            (bag-conj :a)))
;; => #Bag{:a 2, :b 1}

;; Подсчет элементов
(get-count b1 2)
;; => 2

(count-elements b1)
;; => 5

(distinct-count b1)
;; => 3

;; Фильтрация
(bag-filter even? (bag [1 2 3 4 5 2]))
;; => #Bag{2 2, 4 1}

;; Map
(bag-map inc (bag [1 2 3]))
;; => #Bag{2 1, 3 1, 4 1}

;; Свертки
(reduce-left + 0 (bag [1 2 3 2]))
;; => 8

;; Объединение
(bag-union (bag [1 2]) (bag [2 3]))
;; => #Bag{1 1, 2 2, 3 1}

;; Сравнение
(bag-equals? (bag [1 2 2]) (bag [2 1 2]))
;; => true

;; Использование стандартных функций Clojure
(let [b (bag [1 2 3 2 1])]
  (count b)                    ; => 5
  (seq b)                      ; => последовательность элементов
  (get b 2)                    ; => 2
  (contains? b 3)              ; => true
  (some #{2} b)                ; => true
  (every? integer? b)          ; => true
  (set b)                      ; => #{1 2 3}
  (sort (seq b))               ; => [1 1 2 2 3]
  (b 2)                        ; => 2 (вызов bag как функции)
  (cons b 4)                   ; => #Bag{1 2, 2 2, 3 1, 4 1}
  (empty b))                   ; => #Bag{}
```

## Запуск тестов

```bash
lein test
```

## Заключение

В ходе лабораторной работы была реализована структура данных Bag (Multiset) на основе Separate Chaining Hashmap. Ключевой особенностью реализации является использование `deftype` для явной реализации всех интерфейсов стандартных коллекций Clojure, что обеспечивает полную интеграцию со стандартными функциями языка.

Для организации полиморфизма использовались конструкции `instance?` и `defmethod`, которые позволяют определять тип данных и организовывать ветвление на реализации для разных типов (SCBag и стандартные коллекции Clojure).

Были реализованы все требуемые функции, в том числе моноид, для которого были описаны property-based тесты, проверяющие его свойства (ассоциативность, наличие нейтрального элемента). Особое внимание было уделено тестированию: реализовано 15 property-based тестов, которые используют генератор `bag-gen`, создающий bag-и напрямую без промежуточных структур.

Реализация интерфейсов стандартных коллекций (`Seqable`, `Counted`, `IPersistentCollection`, `ILookup`, `IFn`, `Associative`) позволяет использовать `SCBag` со всеми стандартными функциями Clojure (`seq`, `count`, `get`, `cons`, `empty`, `contains?`, `find` и др.), что делает структуру данных полностью совместимой с экосистемой Clojure.

В целом, получена библиотека методов для sc-bag, во внутреннем представлении которой организуются цепочки узлов в бакетах, хранятся уникальные элементы и количества их вхождений. В методах основного API реализованы алгоритмы с использованием внутреннего представления структуры данных, а также алгоритмы для стандартных коллекций (менее оптимизированные, но универсальные).
