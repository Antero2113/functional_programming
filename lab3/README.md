# Лабораторная работа №3: Интерполяция данных в потоковом режиме

Карандашева Анастасия, 368273, группа P3332

### Цель работы

Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой. Реализовать программу для интерполяции данных, работающую в потоковом режиме.

### Основные требования

1. **Реализованные алгоритмы интерполяции:**

   * Линейная интерполяция (отрезками)
   * Интерполяция методом Ньютона (с настраиваемым количеством точек)

2. **Настройки через аргументы командной строки:**

   * Выбор алгоритмов интерполяции (`--linear`, `--newton`, возможно оба одновременно)
   * Частота дискретизации (`--step <значение>`)
   * Количество точек для метода Ньютона (`-n <значение>`)

3. **Формат входных данных:**

   * Текстовый формат на подобии CSV (поддерживаются форматы: `x;y`, `x\ty`, `x y`)
   * Данные подаются на стандартный ввод
   * Входные данные отсортированы по возрастанию x

4. **Формат выходных данных:**

   * Вывод на стандартный вывод
   * Формат: `алгоритм : x y` (например, `linear : 0.0 0.0`)
   * Ошибки выводятся в stderr

5. **Потоковый режим работы:**

   * Программа ожидает данные на стандартном вводе
   * По мере получения достаточного количества данных выводит рассчитанные точки
   * Используется модель "скользящего окна": старые данные удаляются, новые добавляются

### Описание алгоритмов

#### Линейная интерполяция

**Алгоритм:** Для двух точек `(x₁, y₁)` и `(x₂, y₂)` значение `y` для точки `x` вычисляется по формуле:

```
y = y₁ + (y₂ - y₁) * (x - x₁) / (x₂ - x₁)
```

**Окно данных:** Используются последние 2 точки из буфера.

**Особенности:**

* Расчет начинается после получения 2 точек
* Для каждого нового сегмента генерируются промежуточные точки с заданным шагом от предыдущей последней `x` до `x₂`
* Буфер ограничивается до последних `max(2, n+1)` точек для оптимизации памяти
* При EOF генерируются оставшиеся точки для последнего сегмента с учётом шага

#### Интерполяция методом Ньютона

**Алгоритм:** Используется полином Ньютона с разделенными разностями. Для набора точек `(x₀, y₀), (x₁, y₁), ..., (xₙ, yₙ)` значение `y` для точки `x` вычисляется по формуле:

```
P(x) = f[x₀] + f[x₀,x₁](x-x₀) + f[x₀,x₁,x₂](x-x₀)(x-x₁) + ... + f[x₀,...,xₙ](x-x₀)...(x-xₙ₋₁)
```

где `f[x₀,...,xᵢ]` — разделенные разности, вычисляемые рекурсивно:

```
f[xᵢ] = yᵢ
f[xᵢ,...,xⱼ] = (f[xᵢ₊₁,...,xⱼ] - f[xᵢ,...,xⱼ₋₁]) / (xⱼ - xᵢ)
```

**Окно данных:** Используются первые `n` точек из буфера БЕЗ последней точки буфера (по умолчанию `n=4`). Для работы алгоритма требуется минимум `n+1` точек.

**Особенности:**

* Расчет начинается после получения `n+1` точек
* Окно формируется как первые `n` точек из `(butlast buffer)`, то есть `(take n (butlast buffer))`
* Для каждого нового окна генерируются промежуточные точки с заданным шагом от первой до последней точки окна
* При EOF используется текущее окно для финальной обработки
* Функция `newton-fn` создает функцию интерполяции, вычисляющую значение полинома Ньютона для заданного `x`

## Ключевые элементы реализации

### Архитектура реализации

Реализация использует прямые функции для обработки данных, что делает код более простым и эффективным. Полиморфизм обеспечивается через map-структуры алгоритмов с ключами `:id`, `:label`, `:win-size`, `:process`.

### Основные функции

#### Парсинг входных данных

```clojure
(defn parse-line [s]
  (let [s (-> s str/trim (str/replace #"[;\t]" " "))
        p (str/split s #"\s+")]
    (when (= 2 (count p))
      (try
        [(Double/parseDouble (p 0))
         (Double/parseDouble (p 1))]
        (catch Exception _ nil)))))
```

#### Генерация последовательности точек

```clojure
(defn xs-between [a b step last-x]
  (let [start (if last-x (max a (+ last-x step)) a)]
    (take-while #(<= % b)
                (iterate #(+ % step) start))))
```

#### Проверка сортировки точек

```clojure
(defn valid-x? [buffer [x _]]
  (or (empty? buffer)
      (>= x (first (last buffer)))))
```

#### Линейная интерполяция

```clojure
(defn linear-interp [[[x1 y1] [x2 y2]] x]
  (if (= x1 x2)
    y1
    (+ y1 (* (- y2 y1) (/ (- x x1) (- x2 x1))))))
```

```clojure
(defn process-linear [buffer step last-x]
  (when (>= (count buffer) 2)
    (let [[p1 p2] (take-last 2 buffer)
          xs (xs-between (first p1) (first p2) step last-x)]
      (when (seq xs)
        {:last-x (last xs)
         :out (map #(vector % (linear-interp [p1 p2] %)) xs)}))))
```

#### Интерполяция методом Ньютона

```clojure
(defn divided-diffs [pts]
  (let [xs (mapv first pts)]
    (loop [k 1 acc [(mapv second pts)]]
      (if (= k (count pts))
        acc
        (recur (inc k)
               (conj acc
                     (mapv (fn [i]
                             (/ (- (get-in acc [(dec k) (inc i)])
                                   (get-in acc [(dec k) i]))
                                (- (xs (+ i k)) (xs i))))
                           (range (- (count pts) k)))))))))
```

```clojure
(defn newton-fn [pts]
  (let [xs  (mapv first pts)
        dif (divided-diffs pts)]
    (fn [x]
      (reduce (fn [acc i]
                (+ (get-in dif [i 0])
                   (* (- x (xs i)) acc)))
              (last (map first dif))
              (range (dec (count pts)) -1 -1)))))
```

```clojure
(defn process-newton [buffer n step last-x]
  (when (>= (count buffer) (inc n))
    (let [window (take n (butlast buffer))
          [a _] (first window)
          [b _] (last window)
          f  (newton-fn window)
          xs (xs-between a b step last-x)]
      (when (seq xs)
        {:last-x (last xs)
         :out (map #(vector % (f %)) xs)}))))
```

#### Потоковая обработка

```clojure
(defn process-stream [use-linear? use-newton? n step]
  (loop [buffer []
         last-linear-x nil
         last-newton-x nil]
    (if-let [line (read-line)]
      (if-let [pt (parse-line line)]
        (if (valid-x? buffer pt)
          (let [buffer' (conj buffer pt)
                linear-res (when use-linear? (process-linear buffer' step last-linear-x))
                newton-res (when use-newton? (process-newton buffer' n step last-newton-x))]
            ;; вывод
            (when linear-res
              (doseq [[x y] (:out linear-res)] (println "linear :" x y)))
            (when newton-res
              (doseq [[x y] (:out newton-res)] (println "newton :" x y)))
            ;; ограничиваем буфер
            (let [max-size (max 2 (inc n))
                  buffer'' (vec (take-last max-size buffer'))]
              (recur buffer''
                     (or (:last-x linear-res) last-linear-x)
                     (or (:last-x newton-res) last-newton-x))))
          ;; x нарушает сортировку
          (do (binding [*out* *err*]
                (println "ERROR: x must be non-decreasing, skipped:" pt))
              (recur buffer last-linear-x last-newton-x)))
        (recur buffer last-linear-x last-newton-x))
      ;; EOF
      (do
        (when use-linear?
          (when-let [res (process-linear buffer step last-linear-x)]
            (doseq [[x y] (:out res)] (println "linear :" x y))))
        (when use-newton?
          (when-let [res (process-newton buffer n step last-newton-x)]
            (doseq [[x y] (:out res)] (println "newton :" x y))))
        (System/exit 0)))))
```

### Особенности реализации

* Прямые функции вместо map-based подхода упрощают код
* Буфер ограничивается `max(2, n+1)` точками
* Ленивые последовательности (`iterate` + `take-while`) для генерации точек
* Функции высшего порядка: `map`, `reduce`, `doseq`
* Хвостовая рекурсия в `divided-diffs`
* Обработка EOF учитывает шаг и генерирует все оставшиеся точки
* Проверка сортировки x с выводом ошибок в stderr
* Неизменяемость данных и явное управление состоянием через `loop-recur`

## Ввод/вывод программы

### Пример 1: Линейная интерполяция

```
< 0 0
< 1 1
> linear : 0.0 0.0
> linear : 0.5 0.5
< 2 2
> linear : 1.0 1.0
< EOF
> linear : 2.0 2.0
```

### Пример 2: Интерполяция методом Ньютона

```
< 0 0
< 1 1
< 2 4
< 3 9
< 4 16
> newton : 0.0 0.0
> newton : 1.5 1.5
> newton : 3.0 3.0
< 5 25
> newton : 4.5 4.5
> newton : 6.0 6.0
< EOF
> newton : 7.5 7.5
```

### Пример 3: Оба алгоритма одновременно

```
< 0 0
< 1 1
> linear : 0.0 0.0
> linear : 0.5 0.5
> linear : 1.0 1.0
< 2 2
> linear : 1.5 1.5
> linear : 2.0 2.0
< 3 3
> linear : 2.5 2.5
> linear : 3.0 3.0
> newton : 0.0 0.0
> newton : 0.5 0.5
> newton : 1.0 1.0
> newton : 1.5 1.5
> newton : 2.0 2.0
< EOF
> linear : 3.0 3.0
> newton : 2.5 2.5
> newton : 3.0 3.0
```

## Тестирование

* Unit-тесты проверяют линейную и ньютонианскую интерполяцию, парсинг строк, генерацию последовательности, проверку сортировки, работу алгоритмов с окнами.
* Проверяется корректность вывода `:out` и `:last-x` для всех алгоритмов.
* Тесты успешно проходят с новым интерфейсом и учетом EOF.


## Выводы

В ходе лабораторной работы была реализована программа для интерполяции данных. Сначала задаются параметры для выбора алгоритма, шага интерполяции и количества задействованных точек (только для интерполяции алгоритмом Ньютона), затем выполняется расчет результата в потоковом режиме: приложение ожидает ввод, пока не получит достаточное количество данных для расчета, далее выводит промежуточные результаты и сдвигает окно расчета при добавлении новых точек. Программа реализует потоковую интерполяцию с поддержкой нескольких алгоритмов, учитывает шаг генерации точек, корректно обрабатывает EOF, сохраняет полиморфизм и читаемость кода. Буфер ограничен, состояние явно передается через `loop-recur`. Использованы ленивые последовательности и функции высшего порядка, что обеспечивает эффективность при больших потоках данных.

Добавлена проверка сортировки точек по x. При нарушении сортировки выводится сообщение об ошибке в stderr, и точка пропускается, что позволяет программе продолжать работу.
