# Лабораторная работа №3: Интерполяция данных в потоковом режиме
Карандашева Анастасия, 368273, группа P3332

### Цель работы
Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой. Реализовать программу для интерполяции данных, работающую в потоковом режиме.

### Основные требования

1. **Реализованные алгоритмы интерполяции:**
   - Линейная интерполяция (отрезками)
   - Интерполяция методом Ньютона (с настраиваемым количеством точек)

2. **Настройки через аргументы командной строки:**
   - Выбор алгоритмов интерполяции (`--linear`, `--newton`, возможно оба одновременно)
   - Частота дискретизации (`--step <значение>`)
   - Количество точек для метода Ньютона (`-n <значение>`)

3. **Формат входных данных:**
   - Текстовый формат на подобии CSV (поддерживаются форматы: `x;y`, `x\ty`, `x y`)
   - Данные подаются на стандартный ввод
   - Входные данные отсортированы по возрастанию x

4. **Формат выходных данных:**
   - Вывод на стандартный вывод
   - Формат: `алгоритм : x y` (например, `linear : 0.0 0.0`)
   - Ошибки выводятся в stderr

5. **Потоковый режим работы:**
   - Программа ожидает данные на стандартном вводе
   - По мере получения достаточного количества данных выводит рассчитанные точки
   - Используется модель "скользящего окна": старые данные удаляются, новые добавляются

### Описание алгоритмов

#### Линейная интерполяция

**Алгоритм:** Для двух точек `(x₁, y₁)` и `(x₂, y₂)` значение `y` для точки `x` вычисляется по формуле:

```
y = y₁ + (y₂ - y₁) * (x - x₁) / (x₂ - x₁)
```

**Окно данных:** Используются последние 2 точки из буфера.

**Особенности:**
- Расчет начинается после получения 2 точек
- Для каждого нового сегмента генерируются промежуточные точки с заданным шагом от первой до второй точки окна
- Буфер ограничивается до последних `max(2, n+1)` точек для оптимизации памяти
- При EOF генерируются все оставшиеся точки от `last-x + step` до последней точки окна включительно

#### Интерполяция методом Ньютона

**Алгоритм:** Используется полином Ньютона с разделенными разностями. Для набора точек `(x₀, y₀), (x₁, y₁), ..., (xₙ, yₙ)` значение `y` для точки `x` вычисляется по формуле:

```
P(x) = f[x₀] + f[x₀,x₁](x-x₀) + f[x₀,x₁,x₂](x-x₀)(x-x₁) + ... + f[x₀,...,xₙ](x-x₀)...(x-xₙ₋₁)
```

где `f[x₀,...,xᵢ]` — разделенные разности, вычисляемые рекурсивно:

```
f[xᵢ] = yᵢ
f[xᵢ,...,xⱼ] = (f[xᵢ₊₁,...,xⱼ] - f[xᵢ,...,xⱼ₋₁]) / (xⱼ - xᵢ)
```

**Окно данных:** Используются первые `n` точек из буфера БЕЗ последней точки буфера (по умолчанию `n=4`). Это означает, что для работы алгоритма требуется минимум `n+1` точек в буфере.

**Особенности:**
- Расчет начинается после получения `n+1` точек
- Окно формируется как первые `n` точек из `(butlast buffer)`, то есть `(take n (butlast buffer))`
- Для каждого нового окна генерируются промежуточные точки с заданным шагом от первой до последней точки окна
- При EOF используется текущий буфер для финальной обработки
- Функция `newton-fn` создает функцию интерполяции, которая вычисляет значение полинома Ньютона для заданного `x`

## Ключевые элементы реализации

### Архитектура реализации

Реализация использует прямые функции для обработки данных, что делает код более простым и эффективным.

### Основные функции

#### Парсинг входных данных

```clojure
(defn parse-line [s]
  (let [s (-> s str/trim (str/replace #"[;\t]" " "))
        p (str/split s #"\s+")]
    (when (= 2 (count p))
      (try
        [(Double/parseDouble (p 0))
         (Double/parseDouble (p 1))]
        (catch Exception _ nil)))))
```

Функция обрабатывает строки в форматах `x;y`, `x\ty`, `x y`, преобразуя их в пары чисел. Использует регулярное выражение для замены разделителей.

#### Генерация последовательности точек

```clojure
(defn xs-between [a b step last-x]
  (let [start (if last-x (max a (+ last-x step)) a)]
    (take-while #(<= % b)
                (iterate #(+ % step) start))))
```

Генерирует ленивую последовательность точек `x` с заданным шагом от `start` (или с `last-x + step`, если `last-x` задан) до `b`.

#### Проверка сортировки точек

```clojure
(defn valid-x? [buffer [x _]]
  (or (empty? buffer)
      (>= x (first (last buffer)))))
```

Проверяет, что входящие точки отсортированы по возрастанию x. При нарушении сортировки выводится сообщение об ошибке в stderr, и точка пропускается.

#### Линейная интерполяция

```clojure
(defn linear-interp [[[x1 y1] [x2 y2]] x]
  (if (= x1 x2)
    y1
    (+ y1 (* (- y2 y1)
             (/ (- x x1) (- x2 x1))))))
```

Вычисляет значение `y` для точки `x` между двумя заданными точками. Принимает окно из двух точек как первый аргумент.

```clojure
(defn process-linear [buffer step last-x]
  (when (>= (count buffer) 2)
    (let [[p1 p2] (take-last 2 buffer)
          [x1 _] p1
          [x2 _] p2
          xs (xs-between x1 x2 step last-x)]
      (when (seq xs)
        {:last-x (last xs)
         :out (map (fn [x] [x (linear-interp [p1 p2] x)]) xs)}))))
```

Обрабатывает линейную интерполяцию для текущего буфера, возвращая рассчитанные точки в поле `:out` и последнюю `x` в поле `:last-x`.

#### Интерполяция методом Ньютона

```clojure
(defn divided-diffs [pts]
  (let [xs (mapv first pts)]
    (loop [k 1
           acc [(mapv second pts)]]
      (if (= k (count pts))
        acc
        (recur
         (inc k)
         (conj acc
               (mapv
                (fn [i]
                  (/ (- (get-in acc [(dec k) (inc i)])
                        (get-in acc [(dec k) i]))
                     (- (xs (+ i k))
                        (xs i))))
                (range (- (count pts) k)))))))))
```

Вычисляет разделенные разности для набора точек, используя хвостовую рекурсию и `get-in` для доступа к элементам.

```clojure
(defn newton-fn [pts]
  (let [xs  (mapv first pts)
        dif (divided-diffs pts)]
    (fn [x]
      (reduce
       (fn [acc i]
         (+ (get-in dif [i 0])
            (* (- x (xs i)) acc)))
       (last (map first dif))
       (range (dec (count pts)) -1 -1)))))
```

Создает функцию интерполяции Ньютона для набора точек. Возвращает функцию, которая вычисляет значение полинома Ньютона для заданного `x` с использованием предвычисленных разделенных разностей. Вычисление выполняется с помощью `reduce`, проходя по уровням разделенных разностей в обратном порядке.

```clojure
(defn process-newton [buffer n step last-x]
  (when (>= (count buffer) (inc n))
    (let [window (take n (butlast buffer))
          [a _] (first window)
          [b _] (last window)
          f  (newton-fn window)
          xs (xs-between a b step last-x)]
      (when (seq xs)
        {:last-x (last xs)
         :out (map (fn [x] [x (f x)]) xs)}))))
```

Обрабатывает интерполяцию Ньютона для текущего буфера. Окно формируется как первые `n` точек из буфера без последней точки.

#### Парсинг аргументов командной строки

```clojure
(defn parse-args [args]
  {:linear? (some #{"--linear"} args)
   :newton? (some #{"--newton"} args)
   :step    (or (some->> args
                         (drop-while #(not= % "--step"))
                         second
                         Double/parseDouble)
                1.0)
   :n       (or (some->> args
                         (drop-while #(not= % "-n"))
                         second
                         Integer/parseInt)
                4)})
```

Парсит аргументы командной строки, возвращая map с флагами использования алгоритмов, шагом интерполяции и количеством точек для Ньютона. Использует `some->>` для безопасного извлечения значений аргументов.

#### Потоковая обработка

```clojure
(defn process-stream [use-linear? use-newton? n step]
  (loop [buffer []
         last-linear-x nil
         last-newton-x nil]
    (if-let [line (read-line)]
      (if-let [pt (parse-line line)]
        (if (valid-x? buffer pt)
          (let [buffer' (conj buffer pt)
                linear-res (when use-linear?
                             (process-linear buffer' step last-linear-x))
                newton-res (when use-newton?
                             (process-newton buffer' n step last-newton-x))]
            ;; вывод
            (when linear-res
              (doseq [[x y] (:out linear-res)]
                (println "linear :" x y)))
            (when newton-res
              (doseq [[x y] (:out newton-res)]
                (println "newton :" x y)))
            ;; ограничиваем буфер
            (let [max-size (max 2 (inc n))
                  buffer'' (vec (take-last max-size buffer'))]
              (recur buffer''
                     (or (:last-x linear-res) last-linear-x)
                     (or (:last-x newton-res) last-newton-x))))
          ;; x нарушает сортировку
          (do
            (binding [*out* *err*]
              (println "ERROR: x must be non-decreasing, skipped:" pt))
            (recur buffer last-linear-x last-newton-x)))
        (recur buffer last-linear-x last-newton-x))
      ;; EOF
      (do
        (when use-linear?
          (when-let [res (process-linear buffer step last-linear-x)]
            (doseq [[x y] (:out res)]
              (println "linear :" x y))))
        (when use-newton?
          (when-let [res (process-newton buffer n step last-newton-x)]
            (doseq [[x y] (:out res)]
              (println "newton :" x y))))
        (System/exit 0)))))
```

Основной цикл программы:
- Парсит аргументы командной строки
- Читает строки из стандартного ввода
- Проверяет сортировку точек по x с помощью `valid-x?`
- Обновляет буфер точек
- Вызывает соответствующие алгоритмы интерполяции при наличии достаточного количества данных
- Отслеживает последнюю выведенную `x` для каждого алгоритма отдельно
- Ограничивает размер буфера, сохраняя только последние `max(2, n+1)` точек
- При нарушении сортировки выводит ошибку в stderr и пропускает точку
- При EOF выполняет финальный проход для вывода оставшихся точек

### Особенности реализации

1. **Прямые функции вместо map-based подхода:** Используются прямые функции `process-linear` и `process-newton`, что упрощает код и делает его более читаемым.

2. **Оптимизация памяти:** Буфер ограничивается до `max(2, n+1)` точек, что гарантирует достаточное количество данных для работы алгоритмов без избыточного хранения.

3. **Ленивые последовательности:** Функция `xs-between` возвращает ленивую последовательность точек, что позволяет эффективно работать с большими диапазонами без создания промежуточных коллекций.

4. **Функции высшего порядка:** Использование `map`, `reduce`, `doseq` для обработки коллекций. Функция `newton-fn` возвращает функцию интерполяции, что является примером функционального подхода.

5. **Хвостовая рекурсия:** Функция `divided-diffs` использует `recur` для оптимизации стека вызовов.

6. **Обработка ошибок:** При нарушении сортировки ошибка выводится в stderr с помощью `binding [*out* *err*]`, что позволяет отделить ошибки от нормального вывода.

7. **Неизменяемость данных:** Все операции создают новые структуры данных, не изменяя существующие.

8. **Управление состоянием:** Состояние программы (буфер точек, последние выведенные `x` для каждого алгоритма) передается через параметры цикла `loop-recur`.

## Ввод/вывод программы

### Пример 1: Линейная интерполяция

**Команда:**
```bash
lein run --linear --step 0.7
```

**Ввод/вывод:**
```
< 0 0
< 1 1
> linear : 0 0
> linear : 0.7 0.7
< 2 2
> linear : 1.4 1.4
< 3 3
> linear : 2.1 2.1
> linear : 2.8 2.8
< EOF
> linear : 3.0 3.0
```

### Пример 2: Интерполяция методом Ньютона

**Команда:**
```bash
lein run --newton -n 4 --step 0.5
```

**Ввод/вывод:**
```
< 0 0
< 1 1
< 2 2
< 3 3
< 4 4
> newton : 0.0 0.0
> newton : 0.5 0.5
> newton : 1.0 1.0
> newton : 1.5 1.5
> newton : 2.0 2.0
> newton : 2.5 2.5
> newton : 3.0 3.0
< 5 5
> newton : 3.5 3.5
> newton : 4.0 4.0
< 7 7
> newton : 4.5 4.5
> newton : 5.0 5.0
< 8 8
> newton : 5.5 5.5
> newton : 6.0 6.0
> newton : 6.5 6.5
> newton : 7.0 7.0
< EOF
> newton : 7.5 7.5
> newton : 8.0 8.0
```

### Пример 3: Оба алгоритма одновременно

**Команда:**
```bash
lein run --linear --newton --step 0.5 -n 3
```

**Ввод/вывод:**
```
< 0 0
< 1 1
> linear : 0.0 0.0
> linear : 0.5 0.5
> linear : 1.0 1.0
< 2 2
> linear : 1.5 1.5
> linear : 2.0 2.0
< 3 3
> linear : 2.5 2.5
> linear : 3.0 3.0
> newton : 0.0 0.0
> newton : 0.5 0.5
> newton : 1.0 1.0
> newton : 1.5 1.5
> newton : 2.0 2.0
< 4 4
> linear : 3.5 3.5
> linear : 4.0 4.0
> newton : 2.5 2.5
> newton : 3.0 3.0
< EOF
> linear : 4.0 4.0
> newton : 3.5 3.5
> newton : 4.0 4.0
```

## Тестирование

Реализованы unit-тесты для проверки корректности работы алгоритмов, парсинга входных данных и основных функций. Тесты проверяют:

- Корректность линейной интерполяции между двумя точками
- Корректность интерполяции Ньютона для набора точек
- Парсинг строк с координатами в различных форматах
- Проверку сортировки точек
- Генерацию последовательности точек
- Обработку алгоритмов интерполяции

Все тесты проходят успешно.

## Выводы

В ходе лабораторной работы была реализована программа для интерполяции данных. Сначала задаются параметры для выбора алгоритма, шага интерполяции и количества задействованных точек (только для интерполяции алгоритмом Ньютона), затем выполняется расчет результата в потоковом режиме: приложение ожидает ввод, пока не получит достаточное количество данных для расчета, далее выводит промежуточные результаты и сдвигает окно расчета при добавлении новых точек.

Добавлена проверка сортировки точек по x. При нарушении сортировки выводится сообщение об ошибке в stderr, и точка пропускается, что позволяет программе продолжать работу.

Использованы ленивые последовательности (`iterate` и `take-while`) для генерации точек интерполяции, что позволяет работать с большими диапазонами без создания промежуточных коллекций в памяти. Сохранен принцип неизменяемости: все операции создают новые структуры данных. Буфер точек и состояние программы передаются через параметры цикла `loop-recur`. Используются функции высшего порядка: `map`, `reduce`, `doseq`. Функция `newton-fn` демонстрирует создание функций высшего порядка, возвращая функцию интерполяции.
