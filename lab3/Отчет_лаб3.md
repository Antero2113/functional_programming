# Лабораторная работа №3: Интерполяция данных в потоковом режиме
Карандашева Анастасия, 368273, группа P3332

### Цель работы
Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой. Реализовать программу для интерполяции данных, работающую в потоковом режиме.

### Основные требования

1. **Реализованные алгоритмы интерполяции:**
   - Линейная интерполяция (отрезками)
   - Интерполяция методом Ньютона (с настраиваемым количеством точек)

2. **Настройки через аргументы командной строки:**
   - Выбор алгоритмов интерполяции (`--linear`, `--newton`, возможно оба одновременно)
   - Частота дискретизации (`--step <значение>`)
   - Количество точек для метода Ньютона (`-n <значение>`)

3. **Формат входных данных:**
   - Текстовый формат на подобии CSV (поддерживаются форматы: `x;y`, `x\ty`, `x y`)
   - Данные подаются на стандартный ввод
   - Входные данные отсортированы по возрастанию x

4. **Формат выходных данных:**
   - Вывод на стандартный вывод
   - Формат: `алгоритм: x y` (например, `linear: 0.0 0.0`)
   - Округление до 1 десятичного знака

5. **Потоковый режим работы:**
   - Программа ожидает данные на стандартном вводе
   - По мере получения достаточного количества данных выводит рассчитанные точки
   - Используется модель "скользящего окна": старые данные удаляются, новые добавляются

### Описание алгоритмов

#### Линейная интерполяция

**Алгоритм:** Для двух точек `(x₁, y₁)` и `(x₂, y₂)` значение `y` для точки `x` вычисляется по формуле:

```
y = y₁ + (y₂ - y₁) * (x - x₁) / (x₂ - x₁)
```

**Окно данных:** Используются последние 2 точки из буфера.

**Особенности:**
- Расчет начинается после получения 2 точек
- Для каждого нового сегмента генерируются промежуточные точки с заданным шагом
- При EOF выводится последняя рассчитанная точка, если она не была выведена ранее

#### Интерполяция методом Ньютона

**Алгоритм:** Используется полином Ньютона с разделенными разностями. Для набора точек `(x₀, y₀), (x₁, y₁), ..., (xₙ, yₙ)` значение `y` для точки `x` вычисляется по формуле:

```
P(x) = f[x₀] + f[x₀,x₁](x-x₀) + f[x₀,x₁,x₂](x-x₀)(x-x₁) + ... + f[x₀,...,xₙ](x-x₀)...(x-xₙ₋₁)
```

где `f[x₀,...,xᵢ]` — разделенные разности, вычисляемые рекурсивно:

```
f[xᵢ] = yᵢ
f[xᵢ,...,xⱼ] = (f[xᵢ₊₁,...,xⱼ] - f[xᵢ,...,xⱼ₋₁]) / (xⱼ - xᵢ)
```

**Окно данных:** Используются последние `n` точек из буфера (по умолчанию `n=4`).

**Особенности:**
- Расчет начинается после получения `n` точек
- Для каждого нового окна генерируются промежуточные точки с заданным шагом
- При EOF выводится последняя рассчитанная точка, если она не была выведена ранее

## Ключевые элементы реализации

### Основные функции

#### Парсинг входных данных

```clojure
(defn parse-line [s]
  (try
    (let [[a b] (-> s str/trim 
                    (str/replace ";" " ") 
                    (str/replace "\t" " ") 
                    (str/split #"\s+"))]
      [(Double/parseDouble a) (Double/parseDouble b)])
    (catch Exception _ nil)))
```

Функция обрабатывает строки в форматах `x;y`, `x\ty`, `x y`, преобразуя их в пары чисел.

#### Линейная интерполяция

```clojure
(defn linear-interp [[x1 y1] [x2 y2] x]
  (if (= x1 x2)
    y1
    (+ y1 (* (- y2 y1) (/ (- x x1) (- x2 x1))))))
```

Вычисляет значение `y` для точки `x` между двумя заданными точками.

```clojure
(defn linear-range [window]
  "Берем только последние две точки"
  (let [[p1 p2] (take-last 2 window)]
    [(first p1) (first p2)]))
```

Определяет диапазон для линейной интерполяции.

```clojure
(defn gen-xs [start end step last-x]
  (let [start (if last-x
                (max start (+ last-x step))
                start)]
    (when (< start end)
      (->> (iterate #(+ % step) start)
           (take-while #(<= % end))
           vec))))
```

Генерирует последовательность точек `x` с заданным шагом, начиная с `start` (или с `last-x + step`, если `last-x` задан) до `end`.

```clojure
(defn process-linear [window step last-x]
  (let [xs (compute-linear window step last-x)]
    (when (seq xs)
      {:pts (mapv (fn [x] [x (linear-interp (nth window (- (count window) 2))
                                            (last window) x)]) xs)
       :last-x (last xs)})))
```

Обрабатывает линейную интерполяцию для текущего окна, возвращая рассчитанные точки и последнюю `x` для отслеживания непрерывности.

#### Интерполяция методом Ньютона

```clojure
(defn divided-diffs [pts]
  (let [xs (map first pts)
        ys (map second pts)]
    (loop [level 0 acc [(vec ys)]]
      (if (= level (dec (count pts)))
        acc
        (recur (inc level)
               (conj acc
                     (vec (map (fn [a b x1 x0] (/ (- b a) (- x1 x0)))
                               (butlast (last acc))
                               (rest    (last acc))
                               (drop (inc level) xs)
                               (drop       level  xs)))))))))
```

Вычисляет разделенные разности для набора точек, используя хвостовую рекурсию.

```clojure
(defn newton-interp [pts x]
  (let [xs (map first pts)
        dif (divided-diffs pts)]
    (loop [i 1 acc (ffirst dif) w 1.0]
      (if (= i (count pts))
        acc
        (let [w' (* w (- x (nth xs (dec i))))
              acc' (+ acc (* (nth (nth dif i) 0) w'))]
          (recur (inc i) acc' w'))))))
```

Вычисляет значение полинома Ньютона для точки `x`, используя предвычисленные разделенные разности.

```clojure
(defn newton-range [window]
  [(ffirst window) (first (last window))])
```

Определяет диапазон для интерполяции Ньютона (от первой до последней точки в окне).

```clojure
(defn process-newton [window step last-x]
  (let [xs (compute-newton window step last-x)]
    (when (seq xs)
      {:pts (mapv (fn [x] [x (newton-interp window x)]) xs)
       :last-x (last xs)})))
```

Обрабатывает интерполяцию Ньютона для текущего окна.

#### Потоковая обработка

Основной цикл программы:
- Парсит аргументы командной строки
- Читает строки из стандартного ввода
- Обновляет буфер точек
- Вызывает соответствующие алгоритмы интерполяции при наличии достаточного количества данных
- Отслеживает последнюю выведенную `x` для каждого алгоритма, чтобы избежать дублирования
- При EOF выполняет финальный проход для вывода оставшихся точек

### Особенности реализации

1. **Неизменяемость данных:** Все операции создают новые структуры данных, не изменяя существующие.

2. **Ленивые последовательности:** Использование `iterate` и `take-while` для генерации точек позволяет эффективно работать с большими диапазонами.

3. **Хвостовая рекурсия:** Функции `divided-diffs` и `newton-interp` используют `recur` для оптимизации стека вызовов.

4. **Функции высшего порядка:** Использование `mapv`, `filter`, `doseq` для обработки коллекций.

5. **Управление состоянием:** Состояние программы (буфер точек, последние выведенные `x`) передается через параметры цикла `loop-recur`.

## Ввод/вывод программы

### Пример 1: Линейная интерполяция

**Команда:**
```bash
lein run --linear --step 0.7
```

**Ввод/вывод:**
```
< 0 0
< 1 1
> linear: 0 0
> linear: 0.7 0.7
< 2 2
> linear: 1.4 1.4
> 3 3
> linear: 2.1.4 2.1
> linear: 2.8 2.8
< EOF
> linear: 2.8 2.8
```

### Пример 2: Интерполяция методом Ньютона

**Команда:**
```bash
lein run --newton -n 4 --step 0.5
```

**Ввод/вывод:**
```
< 0 0
< 1 1
< 2 2
> 3 3
> 4 4
> newton: 0.0 0.0
> newton: 0.5 0.5
> newton: 1.0 1.0
> newton: 1.5 1.5
> newton: 2.0 2.0
> newton: 2.5 2.5
> newton: 3.0 3.0
< 5 5
> newton: 3.5 3.5
> newton: 4.0 4.0
< 7 7
> newton: 4.5 4.5
> newton: 5.0 5.0
< 8 8
> newton: 5.5 5.5
> newton: 6.0 6.0
> newton: 6.5 6.5
> newton: 7.0 7.0
< EOF
> newton: 7.5 7.5
> newton: 8.0 8.0
```

### Пример 3: Оба алгоритма одновременно

**Команда:**
```bash
lein run --linear --newton --step 0.5 -n 3
```

**Ввод/вывод:**
```
< 0 0
< 1 1
> linear: 0.0 0.0
> linear: 0.5 0.5
> linear: 1.0 1.0
< 2 2
> linear: 1.5 1.5
> linear: 2.0 2.0
< 3 3
> linear: 2.5 2.5
> linear: 3.0 3.0
> newton: 0.0 0.0
> newton: 0.5 0.5
> newton: 1.0 1.0
> newton: 1.5 1.5
> newton: 2.0 2.0
< 4 4
> linear: 3.5 3.5
> linear: 4.0 4.0
> newton: 2.5 2.5
> newton: 3.0 3.0
< EOF
> linear: 4.0 4.0
> newton: 3.5 3.5
> newton: 4.0 4.0
```

## Тестирование

Реализованы unit-тесты для проверки корректности работы алгоритмов:

```clojure
(deftest test-linear-interp
  (testing "Линейная интерполяция между двумя точками"
    (is (= 0.5 (linear-interp [0 0] [1 1] 0.5)))
    (is (= 1.5 (linear-interp [1 1] [2 2] 1.5)))))

(deftest test-newton-interp
  (testing "Интерполяция Ньютона для набора точек"
    (let [points [[0 0] [1 1] [2 4] [3 9]]]
      (is (= 0.0 (newton-interp points 0.0)))
      (is (= 1.0 (newton-interp points 1.0))))))

(deftest test-parse-line
  (testing "Парсинг строк с координатами"
    (is (= [0.0 0.0] (parse-line "0 0")))
    (is (= [1.0 2.0] (parse-line "1;2")))
    (is (= [1.0 2.0] (parse-line "1\t2")))))
```

Все тесты проходят успешно (9 тестов).

## Выводы

В ходе лабораторной работы была реализована программа для интерполяции данных. Сначала задаются параметры для выбора алгоритма, шага интерполяции и количества задействованных точек (только для интерполяции алгоритмом Ньютона), затем выполняется расчет результата в потоковом режиме: приложение ожидает ввод, пока не получит достаточное количество данных для расчета, далее выводит промежуточные результаты и сдвигает окно расчета при добавлении новых точек.

Использованы ленивые последовательности: `iterate` и `take-while` для генерации точек интерполяции позволяют работать с большими диапазонами, не создавая промежуточные коллекции в памяти. Сохранен принцип неизменяемости переменных, характерный для функционального программирования: все операции создают новые структуры данных, что упрощает отслеживание состояния и делает код более предсказуемым. Буфер точек и состояние программы передаются через параметры цикла `loop-recur`, а не через изменяемые переменные. Используются характерные для clojure функции высшего порядка обработки коллекций: `mapv`, `filter`, `doseq`. Там, где это удобно, понятность кода достигается с применением макросов для построения цепочек обработки. Тестирование облегчалось засчет отдельной отладки каждой из выделенных функций.
