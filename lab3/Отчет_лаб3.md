# Лабораторная работа №3: Интерполяция данных в потоковом режиме
Карандашева Анастасия, 368273, группа P3332

## Требования к разработанному ПО

### Цель работы
Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой. Реализовать программу для интерполяции данных, работающую в потоковом режиме.

### Основные требования

1. **Реализованные алгоритмы интерполяции:**
   - Линейная интерполяция (отрезками)
   - Интерполяция методом Ньютона (с настраиваемым количеством точек)

2. **Настройки через аргументы командной строки:**
   - Выбор алгоритмов интерполяции (`--linear`, `--newton`, возможно оба одновременно)
   - Частота дискретизации (`--step <значение>`)
   - Количество точек для метода Ньютона (`-n <значение>`)

3. **Формат входных данных:**
   - Текстовый формат на подобии CSV (поддерживаются форматы: `x;y`, `x\ty`, `x y`)
   - Данные подаются на стандартный ввод
   - Входные данные отсортированы по возрастанию x

4. **Формат выходных данных:**
   - Вывод на стандартный вывод
   - Формат: `алгоритм: x y` (например, `linear: 0.0 0.0`)
   - Округление до 1 десятичного знака

5. **Потоковый режим работы:**
   - Программа ожидает данные на стандартном вводе
   - По мере получения достаточного количества данных выводит рассчитанные точки
   - Используется модель "скользящего окна": старые данные удаляются, новые добавляются

### Описание алгоритмов

#### Линейная интерполяция

**Алгоритм:** Для двух точек `(x₁, y₁)` и `(x₂, y₂)` значение `y` для точки `x` вычисляется по формуле:

```
y = y₁ + (y₂ - y₁) * (x - x₁) / (x₂ - x₁)
```

**Окно данных:** Используются последние 2 точки из буфера.

**Особенности:**
- Расчет начинается после получения 2 точек
- Для каждого нового сегмента генерируются промежуточные точки с заданным шагом
- При EOF выводится последняя рассчитанная точка, если она не была выведена ранее

#### Интерполяция методом Ньютона

**Алгоритм:** Используется полином Ньютона с разделенными разностями. Для набора точек `(x₀, y₀), (x₁, y₁), ..., (xₙ, yₙ)` значение `y` для точки `x` вычисляется по формуле:

```
P(x) = f[x₀] + f[x₀,x₁](x-x₀) + f[x₀,x₁,x₂](x-x₀)(x-x₁) + ... + f[x₀,...,xₙ](x-x₀)...(x-xₙ₋₁)
```

где `f[x₀,...,xᵢ]` — разделенные разности, вычисляемые рекурсивно:

```
f[xᵢ] = yᵢ
f[xᵢ,...,xⱼ] = (f[xᵢ₊₁,...,xⱼ] - f[xᵢ,...,xⱼ₋₁]) / (xⱼ - xᵢ)
```

**Окно данных:** Используются последние `n` точек из буфера (по умолчанию `n=4`).

**Особенности:**
- Расчет начинается после получения `n` точек
- Для каждого нового окна генерируются промежуточные точки с заданным шагом
- При EOF выводится последняя рассчитанная точка, если она не была выведена ранее

## Ключевые элементы реализации

### Структура программы

Программа организована в виде потока обработки данных:

```
+---------------------------+
| обработка входного потока |
+---------------------------+
         |
         v
+-----------------------+  +------------------------------+
| алгоритм интерполяции |<--| генератор точек, для которых |
+-----------------------+  | необходимо вычислить         |
         |                  | промежуточные значения       |
         v                  +------------------------------+
+------------------------+
| печать выходных данных |
+------------------------+
```

### Основные функции

#### Парсинг входных данных

```clojure
(defn parse-line [s]
  (try
    (let [[a b] (-> s str/trim 
                    (str/replace ";" " ") 
                    (str/replace "\t" " ") 
                    (str/split #"\s+"))]
      [(Double/parseDouble a) (Double/parseDouble b)])
    (catch Exception _ nil)))
```

Функция обрабатывает строки в форматах `x;y`, `x\ty`, `x y`, преобразуя их в пары чисел.

#### Линейная интерполяция

```clojure
(defn linear-interp [[x1 y1] [x2 y2] x]
  (if (= x1 x2)
    y1
    (+ y1 (* (- y2 y1) (/ (- x x1) (- x2 x1))))))
```

Вычисляет значение `y` для точки `x` между двумя заданными точками.

```clojure
(defn linear-range [window]
  "Берем только последние две точки"
  (let [[p1 p2] (take-last 2 window)]
    [(first p1) (first p2)]))
```

Определяет диапазон для линейной интерполяции.

```clojure
(defn gen-xs [start end step last-x]
  (let [start (if last-x
                (max start (+ last-x step))
                start)]
    (when (< start end)
      (->> (iterate #(+ % step) start)
           (take-while #(<= % end))
           vec))))
```

Генерирует последовательность точек `x` с заданным шагом, начиная с `start` (или с `last-x + step`, если `last-x` задан) до `end`.

```clojure
(defn process-linear [window step last-x]
  (let [xs (compute-linear window step last-x)]
    (when (seq xs)
      {:pts (mapv (fn [x] [x (linear-interp (nth window (- (count window) 2))
                                            (last window) x)]) xs)
       :last-x (last xs)})))
```

Обрабатывает линейную интерполяцию для текущего окна, возвращая рассчитанные точки и последнюю `x` для отслеживания непрерывности.

#### Интерполяция методом Ньютона

```clojure
(defn divided-diffs [pts]
  (let [xs (map first pts)
        ys (map second pts)]
    (loop [level 0 acc [(vec ys)]]
      (if (= level (dec (count pts)))
        acc
        (recur (inc level)
               (conj acc
                     (vec (map (fn [a b x1 x0] (/ (- b a) (- x1 x0)))
                               (butlast (last acc))
                               (rest    (last acc))
                               (drop (inc level) xs)
                               (drop       level  xs)))))))))
```

Вычисляет разделенные разности для набора точек, используя хвостовую рекурсию.

```clojure
(defn newton-interp [pts x]
  (let [xs (map first pts)
        dif (divided-diffs pts)]
    (loop [i 1 acc (ffirst dif) w 1.0]
      (if (= i (count pts))
        acc
        (let [w' (* w (- x (nth xs (dec i))))
              acc' (+ acc (* (nth (nth dif i) 0) w'))]
          (recur (inc i) acc' w'))))))
```

Вычисляет значение полинома Ньютона для точки `x`, используя предвычисленные разделенные разности.

```clojure
(defn newton-range [window]
  [(ffirst window) (first (last window))])
```

Определяет диапазон для интерполяции Ньютона (от первой до последней точки в окне).

```clojure
(defn process-newton [window step last-x]
  (let [xs (compute-newton window step last-x)]
    (when (seq xs)
      {:pts (mapv (fn [x] [x (newton-interp window x)]) xs)
       :last-x (last xs)})))
```

Обрабатывает интерполяцию Ньютона для текущего окна.

#### Потоковая обработка

```clojure
(defn -main [& args]
  (let [algos (->> args
                   (filter #(#{"--linear" "--newton"} %))
                   (map {"--linear" :linear "--newton" :newton})
                   (into []))
        algos (if (empty? algos) [:linear] algos)
        
        step-idx (.indexOf args "--step")
        step (if (and (>= step-idx 0) (< (inc step-idx) (count args)))
               (Double/parseDouble (nth args (inc step-idx)))
               1.0)
        
        n-idx (.indexOf args "-n")
        n (if (and (>= n-idx 0) (< (inc n-idx) (count args)))
            (Integer/parseInt (nth args (inc n-idx)))
            4)]
    
    (loop [{:keys [buffer last] :or {buffer [] last {}}} {:buffer [] :last {}}]
      (if-let [line (read-line)]
        (if-let [pt (parse-line line)]
          (let [buf2 (conj buffer pt)
                last-linear
                (if (and (some #{:linear} algos) (>= (count buf2) 2))
                  (let [window (take-last 2 buf2)
                        lr (get last :linear)
                        res (process-linear window step lr)]
                    (when res
                      (doseq [[x y] (:pts res)]
                        (println "linear:" x y))
                      (:last-x res)))
                
                last-newton
                (if (and (some #{:newton} algos) (>= (count buf2) (inc n)))
                  (let [window (take-last n (butlast buf2))
                        lr (get last :newton)
                        res (process-newton window step lr)]
                    (when res
                      (doseq [[x y] (:pts res)]
                        (println "newton:" x y))
                      (:last-x res)))]
            
            (recur {:buffer buf2
                    :last (cond-> last
                            last-linear (assoc :linear last-linear)
                            last-newton (assoc :newton last-newton))}))
          
          (recur {:buffer buffer :last last}))
        
        (do
          (when (and (some #{:linear} algos) (>= (count buffer) 2))
            (let [window (take-last 2 buffer)
                  lr (get last :linear)
                  res (process-final-linear window step lr)]
              (doseq [[x y] res]
                (println "linear:" x y))))
          
          (when (and (some #{:newton} algos) (>= (count buffer) n))
            (let [window (take-last n buffer)
                  lr (get last :newton)
                  res (process-final-newton window step lr)]
              (doseq [[x y] res]
                (println "newton:" x y))))
          
          (System/exit 0))))))
```

Основной цикл программы:
- Парсит аргументы командной строки
- Читает строки из стандартного ввода
- Обновляет буфер точек
- Вызывает соответствующие алгоритмы интерполяции при наличии достаточного количества данных
- Отслеживает последнюю выведенную `x` для каждого алгоритма, чтобы избежать дублирования
- При EOF выполняет финальный проход для вывода оставшихся точек

### Особенности реализации

1. **Неизменяемость данных:** Все операции создают новые структуры данных, не изменяя существующие.

2. **Ленивые последовательности:** Использование `iterate` и `take-while` для генерации точек позволяет эффективно работать с большими диапазонами.

3. **Хвостовая рекурсия:** Функции `divided-diffs` и `newton-interp` используют `recur` для оптимизации стека вызовов.

4. **Функции высшего порядка:** Использование `mapv`, `filter`, `doseq` для обработки коллекций.

5. **Управление состоянием:** Состояние программы (буфер точек, последние выведенные `x`) передается через параметры цикла `loop-recur`.

## Ввод/вывод программы

### Пример 1: Линейная интерполяция

**Команда:**
```bash
my_lab3 --linear --step 0.7
```

**Ввод:**
```
0 0
1 1
2 2
3 3
EOF
```

**Вывод:**
```
linear: 0.0 0.0
linear: 0.7 0.7
linear: 1.4 1.4
linear: 2.1 2.1
linear: 2.8 2.8
linear: 2.8 2.8
```

**Объяснение:**
- После получения точек `(0,0)` и `(1,1)` выводятся точки `0.0` и `0.7` с шагом `0.7`
- После получения точки `(2,2)` выводятся точки `1.4` и `2.1` (продолжение с последней выведенной `x`)
- После получения точки `(3,3)` выводятся точки `2.8` (продолжение с последней выведенной `x`)
- При EOF выводится последняя рассчитанная точка `2.8`

### Пример 2: Интерполяция методом Ньютона

**Команда:**
```bash
my_lab3 --newton -n 4 --step 0.5
```

**Ввод:**
```
0 0
1 1
2 2
3 3
5 5
7 7
8 8
EOF
```

**Вывод:**
```
newton: 0.0 0.0
newton: 0.5 0.5
newton: 1.0 1.0
newton: 1.5 1.5
newton: 2.0 2.0
newton: 2.5 2.5
newton: 3.0 3.0
newton: 3.5 3.5
newton: 4.0 4.0
newton: 4.5 4.5
newton: 5.0 5.0
newton: 5.5 5.5
newton: 6.0 6.0
newton: 6.5 6.5
newton: 7.0 7.0
newton: 7.5 7.5
newton: 8.0 8.0
```

**Объяснение:**
- Расчет начинается после получения 4 точек (окно `[0,1,2,3]`)
- Для каждого нового окна генерируются промежуточные точки с шагом `0.5`
- При EOF выводится последняя рассчитанная точка

### Пример 3: Оба алгоритма одновременно

**Команда:**
```bash
my_lab3 --linear --newton --step 0.5 -n 3
```

**Ввод:**
```
0 0
1 1
2 4
3 9
EOF
```

**Вывод:**
```
linear: 0.0 0.0
linear: 0.5 0.5
linear: 1.0 1.0
newton: 0.0 0.0
newton: 0.5 0.5
newton: 1.0 1.0
newton: 1.5 2.5
newton: 2.0 4.0
linear: 1.5 2.5
linear: 2.0 4.0
linear: 2.5 6.5
linear: 3.0 9.0
newton: 2.5 6.5
newton: 3.0 9.0
```

**Объяснение:**
- Линейная интерполяция работает с окном из 2 точек
- Интерполяция Ньютона работает с окном из 3 точек
- Оба алгоритма работают параллельно, выводя результаты по мере поступления данных

## Тестирование

Реализованы unit-тесты для проверки корректности работы алгоритмов:

```clojure
(deftest test-linear-interp
  (testing "Линейная интерполяция между двумя точками"
    (is (= 0.5 (linear-interp [0 0] [1 1] 0.5)))
    (is (= 1.5 (linear-interp [1 1] [2 2] 1.5)))))

(deftest test-newton-interp
  (testing "Интерполяция Ньютона для набора точек"
    (let [points [[0 0] [1 1] [2 4] [3 9]]]
      (is (= 0.0 (newton-interp points 0.0)))
      (is (= 1.0 (newton-interp points 1.0))))))

(deftest test-parse-line
  (testing "Парсинг строк с координатами"
    (is (= [0.0 0.0] (parse-line "0 0")))
    (is (= [1.0 2.0] (parse-line "1;2")))
    (is (= [1.0 2.0] (parse-line "1\t2")))))
```

Все тесты проходят успешно (9 тестов, 33 утверждения).

## Выводы

В ходе лабораторной работы была реализована программа для интерполяции данных в потоковом режиме на языке Clojure. Основные выводы:

### Использованные приёмы функционального программирования

1. **Неизменяемость данных:** Все операции создают новые структуры данных, что упрощает отслеживание состояния и делает код более предсказуемым. Буфер точек и состояние программы передаются через параметры цикла `loop-recur`, а не через изменяемые переменные.

2. **Хвостовая рекурсия:** Функции `divided-diffs` и `newton-interp` используют `recur` для оптимизации стека вызовов. Это позволяет эффективно обрабатывать большие наборы данных без риска переполнения стека.

3. **Ленивые последовательности:** Использование `iterate` и `take-while` для генерации точек интерполяции позволяет эффективно работать с большими диапазонами, не создавая промежуточные коллекции в памяти.

4. **Функции высшего порядка:** Широкое использование `mapv`, `filter`, `doseq` для обработки коллекций делает код более декларативным и читаемым.

5. **Композиция функций:** Использование `->` (thread-first) и `->>` (thread-last) макросов для построения цепочек преобразований данных упрощает чтение и понимание кода.

6. **Разделение ответственности:** Код организован в виде небольших чистых функций, каждая из которых решает конкретную задачу. Это упрощает тестирование и поддержку кода.

### Особенности реализации потокового режима

Потоковый режим работы реализован через основной цикл `loop-recur`, который:
- Читает данные построчно из стандартного ввода
- Обновляет буфер точек при получении новых данных
- Вызывает алгоритмы интерполяции при наличии достаточного количества данных
- Отслеживает последнюю выведенную `x` для каждого алгоритма, чтобы избежать дублирования точек
- Обрабатывает EOF для вывода оставшихся точек

### Сложности и их решения

1. **Управление состоянием:** Отслеживание последней выведенной `x` для каждого алгоритма потребовало введения структуры `last` в состоянии программы. Это позволило корректно обрабатывать непрерывность вывода при смене окон данных.

2. **Обработка EOF:** Реализация финального прохода при EOF потребовала создания отдельных функций `process-final-linear` и `process-final-newton`, которые гарантируют вывод последней рассчитанной точки.

3. **Парсинг аргументов командной строки:** Реализация парсинга аргументов через индексы и проверку границ массива оказалась достаточно простой и эффективной для данной задачи.

### Преимущества функционального подхода

1. **Тестируемость:** Чистые функции легко тестировать изолированно, что позволило создать набор unit-тестов для проверки корректности алгоритмов.

2. **Читаемость:** Декларативный стиль кода делает его более понятным и легким для поддержки.

3. **Надежность:** Неизменяемость данных и отсутствие побочных эффектов в чистых функциях снижают риск ошибок при работе с данными.

В целом, реализация продемонстрировала эффективность функционального подхода для задач потоковой обработки данных, где важно управление состоянием и непрерывность вывода.

